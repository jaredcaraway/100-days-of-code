# #100DaysOfCode Log - Round 1 - Jared Caraway

The log of my #100DaysOfCode challenge. Started on Saturday, March 24, 2018.

## Log

### R1D1 - March 24, 2018
I learned some new Terminal commands today - if you press Ctrl+W, you can delete a word at a time. If you want to repeat a command, hold Alt and type in the number of times you want it repeated, followed by the keyboard shortcut - so to delete the last three words you've entered, you'd press Alt+3 followed by Ctrl+W. Nifty.

I recently upgraded my laptop's HDD to a SSD, and the difference is amazing. I put the old HDD into my desktop PC upstairs (which is also now primarily running on an SSD) as a secondary drive. I also installed Mint Linux on both, and I'm loving it so far - my last daily OS was Ubuntu 16.04 LTS, and so far I haven't really missed it (largely because they're so similar).

The downside to the new SSD on my laptop is that I didn't transfer anything over, so I'm starting from scratch. This has caused a bit of a headache when I start working on a project on one and switch to the other; I realized I needed a solution to sync files between the two machines. After experimenting with a manual networking setup that wasn't quite to my satisfaction and a very disappointing implementation of Dropbox, I discovered the free open-source utility called Syncthing. I installed it on both machines, added a startup command for both so that the server runs whenever I start either one, and dropped the stuff I wanted shared into the default directory that was created in my home directory...and it worked with no hassle at all. It's exactly what I needed, and it's going to make my work a lot smoother.

I am currently learning binary trees. I understand the basic concepts, now I just need to figure out how to get them to translate into code. This is going to require relearning recursion, which I haven't worked with in some time. Ultimately, I'll use this knowledge to solve a coding problem that is asking me to serialize and deserialize a binary tree. I could switch to Python and use their built-in "pickling" functionality, but I think I'm going to remain focused on JavaScript until I have obtained a fairly solid mastery of the language.

### R1D2 - March 25, 2018
Today I continued my education on binary trees. I was initially confused about how to decide which node to set as root - take the middle element in an array, maybe? I asked the question on an IRC channel I frequent, and someone clarified that it doesn't really matter, since the tree will sort itself out when done properly. It seems like you can just start with the first element in an array, whether or not it's sorted, and get largely the same result as if you'd started in the middle. An interesting feature of a binary tree is that it will often not be balanced - the left and right subtrees will not be symmetrical.

I learned that there are, as far as I know, only two search algorithms: breadth-first search (BFS) and depth-first search (DFS). In the former, you search starting with the root and examining first the left and then the right child nodes, then the left and right nodes of each of those nodes, and so on until you've searched the entire tree or found the search term. With DFS, you search along the left edge of the tree until you hit a node with no further left children, search the right child node (if any), then return to the level above to check the right nodes backward to the root node, at which point you begin the same search pattern starting with the root node's right child.

In the process of learning about binary trees, I did a bit of reading on heaps as well. They follow a similar form of organization, but do not have the same strict sorting criteria. Heaps tend to be more balanced than binary trees in terms of overall structure, but are not as efficient.

I'd really like to jump in and start coding the answer to the binary search tree serialization problem, but I'm finding that educating myself before going in blind is probably the better way to go. Binary trees appear to be an important concept that I'll need to have in my toolbox, so it's better for me to take the time to understand the concept rather than stitch together some code that's just good enough to solve the coding challenge but which I'll quickly forget about as I move forward.

### R1D3 - March 26, 2018
Today, my coding focused mainly on the MEAN stack - MongoDB, Express, Angular, and Node. Creating a MEAN app involves a lot of moving parts - creating routes, installing packages, creating data models for my database - but it's fascinating seeing under the hood at how everything interconnects.

I continued my education on the topic of binary trees as well today. In the process, I homed in on the subject of classes in JavaScript. An interesting fact I learned about JS classes is that, since it is a prototype-based language, creating an instance of a JS object does not simply make a copy based on the class template; the instance is linked to the prototype, and any methods or attributes added to the prototype after objects are instantiated will add that data to the preexisting objects. I never would have guessed!

### R1D4 - March 27, 2018
More binary trees today, sort of - I looked into the concept of recursion, which I've used before...almost a decade and a half ago in my C++ class! I will need to use this when constructing a binary tree from an array, so I decided to do a little more research. I learned about the execution context stack, which keeps track of the state of your variables and the current line number when a function is called. If the function calls itself from within, a new context is added to the top of the stack. Assuming you haven't coded an infinite loop, new contexts will continue being added until a condition is met, at which point the JavaScript engine traverses the execution context stack from top to bottom until the stack has been cleared. With this knowledge, the binary tree problem is really starting to take focus in my mind. I think I will whiteboard the contexts for clarity when I'm writing the code so I can visualize what's going on. 

I also returned to the MEAN stack and learned, with the help of the Mongoose package, how to create an object according to a defined schema and save it to MongoDB. As a side note, since this requires me to run Angular, Node, and MongoDB in separate terminals, I figured out the keyboard shortcut to quickly move a window to a new workspace (basically, a distinct desktop context), how to rename the workspace for clarity, and how to switch the active workspace. I also added a function to my .bashrc file which allows me to rename the terminal window with a single command for further clarity; I've got a pretty tidy workspace with minimal clutter, which allows me to better focus on the task at hand (instead of Alt-Tabbing through a number of unnamed terminals that I do not need to interact with).

Finally, I finished chapter three of my agile book, which deals with the concepts of continuing to learn to prevent stagnation, sharing that new information with your team to collectively increase knowledge so your team is richer for it as a whole, and unlearning old habits and techniques that may have been superseded by something better. As a lifelong learner, I don't think I'll have any problem with this aspect of agility in my professional development career - I love picking up new concepts.

### R1D5 - March 28, 2018
Today I learned the build flow that is followed when assembling an Angular component (which requires *so many* files), and I also learned how to apply custom styling to that particular component. I am getting some exposure to TypeScript in the process, and it really isn't difficult at all. In fact, I'm having a hard time distinguishing it from regular JavaScript so far - but I'm barely scratching the surface, so I don't want to speak too soon.

I also learned how to apply two-way data binding between an input field and a respective output field via string interpolation. Having done this previously in Vue, I have to say I appreciate Vue's syntax more, but I appear to be accomplishing the *exact same thing* in Angular.

On the non-coding front, I read part of chapter 4 in my agile book, spoke to a friend in the tech industry who works for a major corporation and got a few pointers, and listened to a couple of Base.cs podcast episodes dealing with binary trees. My daily coding problem emails continue to pile up in my inbox, but they're really not a priority at the moment - I can't rush progress, and I have to be realistic about that.

When flipping through job postings again today, it occurred to me that one of the skills I lack completely is .NET/C# proficiency - traditionally Windows-based technology. I discovered that it's possible to develop for this framework/language pair on Linux and went ahead and set up my environment with MonoDevelop and .NET Core, but I refrained from getting too deep into my exploration for fear of winding up in a rabbit hole and losing sight of my current objectives. One thing at a time.

### R1D6 - March 29, 2018
My journey into Angular is exciting, if a little overwhelming. I know, as with anything else I've learned, that it's a matter of repetition and habit, so I'm trying not to sidetrack myself so I can get in a little bit of learning every day and build familiarity by working with it on a regular basis. I'm still just following tutorials, but I'm anxious to take the training wheels off and try out what I'm learning on a project I build entirely myself. There isn't anything I'm learning that is very difficult to understand, but the sheer granularity of the project file structure is taking some adjusting. But I'm confident that I'll be competent in Angular before I even realize it's happened.

Today I continued on into property binding and learned how to pass properties between components. I also learned event binding, which allows me to call a function upon clicking a component with an appropriate binding. I'm still getting used to the concept of sharing data between components...it's all a matter of repetition.

I keep seeing continuous integration/deployment mentioned on job postings, so I've installed Jenkins on my system to begin getting acquainted with it. I'm honestly not sure yet that any of my little projects/experiments can benefit greatly from it, but I believe it'll be valuable for me to familiarize myself with the process for when the scope of my work increases in complexity.

My OS of choice at the moment is Linux Mint. A handy thing I learned today is that you can open additional tabs in Terminal - I had absolutely no idea! When working locally on the MEAN project (Mongo/Express/Angular/Node) I'm on at the moment, I need to run Node in one terminal, the front-end build in another, and MongoDB in a third. This became cumbersome to do repeatedly, so I (with the help of some Googling) wrote a Bash script that opens all three terminal instances (tabbed, now that I know such a thing is possible) by running a single command. It's not much, but it'll speed up my workflow marginally. I've been basically running Linux distros full-time for at least the past seven months, and every day I realize that I've still only scratched the surface of what I can do with the right commands. Learning terminal has been a huge step forward for me as a developer...I've got decades of experience in Windows, but I always relied mainly on GUI. In Linux, I always try to find a CLI-based method for doing stuff. With tab autocompletion, it's so much quicker.