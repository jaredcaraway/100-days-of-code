## 100DaysOfCode Log - Round 1 - Jared Caraway

The log of my #100DaysOfCode challenge. Started on Saturday, March 24, 2018.

## Log

### R1D1 - March 24, 2018
I learned some new Terminal commands today - if you press Ctrl+W, you can delete a word at a time. If you want to repeat a command, hold Alt and type in the number of times you want it repeated, followed by the keyboard shortcut - so to delete the last three words you've entered, you'd press Alt+3 followed by Ctrl+W. Nifty.

I recently upgraded my laptop's HDD to a SSD, and the difference is amazing. I put the old HDD into my desktop PC upstairs (which is also now primarily running on an SSD) as a secondary drive. I also installed Mint Linux on both, and I'm loving it so far - my last daily OS was Ubuntu 16.04 LTS, and so far I haven't really missed it (largely because they're so similar).

The downside to the new SSD on my laptop is that I didn't transfer anything over, so I'm starting from scratch. This has caused a bit of a headache when I start working on a project on one and switch to the other; I realized I needed a solution to sync files between the two machines. After experimenting with a manual networking setup that wasn't quite to my satisfaction and a very disappointing implementation of Dropbox, I discovered the free open-source utility called Syncthing. I installed it on both machines, added a startup command for both so that the server runs whenever I start either one, and dropped the stuff I wanted shared into the default directory that was created in my home directory...and it worked with no hassle at all. It's exactly what I needed, and it's going to make my work a lot smoother.

I am currently learning binary trees. I understand the basic concepts, now I just need to figure out how to get them to translate into code. This is going to require relearning recursion, which I haven't worked with in some time. Ultimately, I'll use this knowledge to solve a coding problem that is asking me to serialize and deserialize a binary tree. I could switch to Python and use their built-in "pickling" functionality, but I think I'm going to remain focused on JavaScript until I have obtained a fairly solid mastery of the language.

### R1D2 - March 25, 2018
Today I continued my education on binary trees. I was initially confused about how to decide which node to set as root - take the middle element in an array, maybe? I asked the question on an IRC channel I frequent, and someone clarified that it doesn't really matter, since the tree will sort itself out when done properly. It seems like you can just start with the first element in an array, whether or not it's sorted, and get largely the same result as if you'd started in the middle. An interesting feature of a binary tree is that it will often not be balanced - the left and right subtrees will not be symmetrical.

I learned that there are, as far as I know, only two search algorithms: breadth-first search (BFS) and depth-first search (DFS). In the former, you search starting with the root and examining first the left and then the right child nodes, then the left and right nodes of each of those nodes, and so on until you've searched the entire tree or found the search term. With DFS, you search along the left edge of the tree until you hit a node with no further left children, search the right child node (if any), then return to the level above to check the right nodes backward to the root node, at which point you begin the same search pattern starting with the root node's right child.

In the process of learning about binary trees, I did a bit of reading on heaps as well. They follow a similar form of organization, but do not have the same strict sorting criteria. Heaps tend to be more balanced than binary trees in terms of overall structure, but are not as efficient.

I'd really like to jump in and start coding the answer to the binary search tree serialization problem, but I'm finding that educating myself before going in blind is probably the better way to go. Binary trees appear to be an important concept that I'll need to have in my toolbox, so it's better for me to take the time to understand the concept rather than stitch together some code that's just good enough to solve the coding challenge but which I'll quickly forget about as I move forward.

### R1D3 - March 26, 2018
Today, my coding focused mainly on the MEAN stack - MongoDB, Express, Angular, and Node. Creating a MEAN app involves a lot of moving parts - creating routes, installing packages, creating data models for my database - but it's fascinating seeing under the hood at how everything interconnects.

I continued my education on the topic of binary trees as well today. In the process, I homed in on the subject of classes in JavaScript. An interesting fact I learned about JS classes is that, since it is a prototype-based language, creating an instance of a JS object does not simply make a copy based on the class template; the instance is linked to the prototype, and any methods or attributes added to the prototype after objects are instantiated will add that data to the preexisting objects. I never would have guessed!

### R1D4 - March 27, 2018
More binary trees today, sort of - I looked into the concept of recursion, which I've used before...almost a decade and a half ago in my C++ class! I will need to use this when constructing a binary tree from an array, so I decided to do a little more research. I learned about the execution context stack, which keeps track of the state of your variables and the current line number when a function is called. If the function calls itself from within, a new context is added to the top of the stack. Assuming you haven't coded an infinite loop, new contexts will continue being added until a condition is met, at which point the JavaScript engine traverses the execution context stack from top to bottom until the stack has been cleared. With this knowledge, the binary tree problem is really starting to take focus in my mind. I think I will whiteboard the contexts for clarity when I'm writing the code so I can visualize what's going on. 

I also returned to the MEAN stack and learned, with the help of the Mongoose package, how to create an object according to a defined schema and save it to MongoDB. As a side note, since this requires me to run Angular, Node, and MongoDB in separate terminals, I figured out the keyboard shortcut to quickly move a window to a new workspace (basically, a distinct desktop context), how to rename the workspace for clarity, and how to switch the active workspace. I also added a function to my .bashrc file which allows me to rename the terminal window with a single command for further clarity; I've got a pretty tidy workspace with minimal clutter, which allows me to better focus on the task at hand (instead of Alt-Tabbing through a number of unnamed terminals that I do not need to interact with).

Finally, I finished chapter three of my agile book, which deals with the concepts of continuing to learn to prevent stagnation, sharing that new information with your team to collectively increase knowledge so your team is richer for it as a whole, and unlearning old habits and techniques that may have been superseded by something better. As a lifelong learner, I don't think I'll have any problem with this aspect of agility in my professional development career - I love picking up new concepts.

### R1D5 - March 28, 2018
Today I learned the build flow that is followed when assembling an Angular component (which requires *so many* files), and I also learned how to apply custom styling to that particular component. I am getting some exposure to TypeScript in the process, and it really isn't difficult at all. In fact, I'm having a hard time distinguishing it from regular JavaScript so far - but I'm barely scratching the surface, so I don't want to speak too soon.

I also learned how to apply two-way data binding between an input field and a respective output field via string interpolation. Having done this previously in Vue, I have to say I appreciate Vue's syntax more, but I appear to be accomplishing the *exact same thing* in Angular.

On the non-coding front, I read part of chapter 4 in my agile book, spoke to a friend in the tech industry who works for a major corporation and got a few pointers, and listened to a couple of Base.cs podcast episodes dealing with binary trees. My daily coding problem emails continue to pile up in my inbox, but they're really not a priority at the moment - I can't rush progress, and I have to be realistic about that.

When flipping through job postings again today, it occurred to me that one of the skills I lack completely is .NET/C# proficiency - traditionally Windows-based technology. I discovered that it's possible to develop for this framework/language pair on Linux and went ahead and set up my environment with MonoDevelop and .NET Core, but I refrained from getting too deep into my exploration for fear of winding up in a rabbit hole and losing sight of my current objectives. One thing at a time.

### R1D6 - March 29, 2018
My journey into Angular is exciting, if a little overwhelming. I know, as with anything else I've learned, that it's a matter of repetition and habit, so I'm trying not to sidetrack myself so I can get in a little bit of learning every day and build familiarity by working with it on a regular basis. I'm still just following tutorials, but I'm anxious to take the training wheels off and try out what I'm learning on a project I build entirely myself. There isn't anything I'm learning that is very difficult to understand, but the sheer granularity of the project file structure is taking some adjusting. But I'm confident that I'll be competent in Angular before I even realize it's happened.

Today I continued on into property binding and learned how to pass properties between components. I also learned event binding, which allows me to call a function upon clicking a component with an appropriate binding. I'm still getting used to the concept of sharing data between components...it's all a matter of repetition.

I keep seeing continuous integration/deployment mentioned on job postings, so I've installed Jenkins on my system to begin getting acquainted with it. I'm honestly not sure yet that any of my little projects/experiments can benefit greatly from it, but I believe it'll be valuable for me to familiarize myself with the process for when the scope of my work increases in complexity.

My OS of choice at the moment is Linux Mint. A handy thing I learned today is that you can open additional tabs in Terminal - I had absolutely no idea! When working locally on the MEAN project (Mongo/Express/Angular/Node) I'm on at the moment, I need to run Node in one terminal, the front-end build in another, and MongoDB in a third. This became cumbersome to do repeatedly, so I (with the help of some Googling) wrote a Bash script that opens all three terminal instances (tabbed, now that I know such a thing is possible) by running a single command. It's not much, but it'll speed up my workflow marginally. I've been basically running Linux distros full-time for at least the past seven months, and every day I realize that I've still only scratched the surface of what I can do with the right commands. Learning terminal has been a huge step forward for me as a developer...I've got decades of experience in Windows, but I always relied mainly on GUI. In Linux, I always try to find a CLI-based method for doing stuff. With tab autocompletion, it's so much quicker.

### R1D7 - April 1, 2018
Writing my Bash script yesterday to automate the opening of multiple terminal windows and running commands within each gave me a big confidence boost, so it led me to examine my process for posting/tweeting about these logs. My basic workflow is as follows: Write about what I did today, commit that, push it to the master branch on origin, switch to browser and open repo page, copy link to log, open Twitter and click tweet button, manually type my tweet and paste link to log, then send it out.

I devised a script rather quickly that allows me to push my staged commit (I may revise to include the actual committing in the script, but for now I'll do it manually), then automatically open a new tab in my browser with a Twitter [web intent](https://dev.twitter.com/web/tweet-button/web-intent) containing a boilerplate with a link to my log (it is always the same file and thus the same URL). This cuts out *so much* of the stuff in the middle! I'm pretty happy about it. The downside is that the web intent doesn't appear to have a built-in character counter...I'll look into whether I can get it to pop up, as I've seen it present when using it in other contexts.

I took a little break from my Angular learning tonight to watch the first lecture in the MIT 6.006 course, which I've seen recommended on multiple occasions to people like me who are pursuing a career in the programming world (without the benefit of actually going to school for it). An understanding of common algorithms is crucial to writing and understanding code, and this course appears to be devoted entirely to such a topic. The first video is called "Algorithmic Thinking, Peak Finding." So far, I'm enjoying it. I'm hopeful that this will help me as I continue knocking out coding algorithm challenges.

### R1D8 - April 2, 2018
Today I continued learning about Angular, but took a step back for a bit to learn about some of the basic concepts upon which Angular builds - beginning with modules. The module system has been unfamiliar to me since I began my Angular journey, and I learned that it's a concept not unique to Angular, but intrinsic to JavaScript ES6 itself (and, if I understand correctly, the future of JS as we know it).

Each module has a scope that is, by default, local rather than global. This causes modules to be agnostic of one another until you explicitly export (that is, make public) a function, class, var, let, or const. This allows for code splitting, which in turn allows for a neater structure and separation of concerns for various scripts.

I alternate between my desktop PC upstairs and my laptop, which I sometimes use upstairs in parallel with the desktop and often take downstairs with me. I originally had set up SyncAnything on both machines, thinking it would be a good idea to just drop the repos I'm working on into my Sync folder to have them automatically mirrored onto both machines. This actually caused some issues with Git, so I reverted to just pulling a local copy to each machine in a non-synced folder. Sometimes I'll shut down my desktop to come downstairs for the night, but I'm not down writing out my log for the day. To remedy this, I've started creating a branch and pushing it to origin so I could then pull it onto my laptop while I'm downstairs to finish it up and post.

This works well enough, but I found after merging and deleting my local branch that the remote branch still persisted. It's possible to log onto Github and remove the remote branch via GUI, but I always opt for a CLI method when it's available. This led me to learn a new skill - deleting remote branches via terminal! It's a bit counterintuitive, but all you do is `git push origin --delete branchNameHere` and that pesky remote branch vanishes. I feel fairly competent in Git by now, but I still have so much left to learn before I can truly say I've mastered it.

I spent a lot of time tonight looking for a good CMS/admin panel to pop onto the MEAN-stack-based project I'm preparing to begin on for a client. For selfish/practice reasons (see: my portfolio), I'm wanting to go the Node route rather than just throwing together something in WordPress (which would be much quicker and easier, if overkill for this particular project). There doesn't seem to be a clear candidate at this point, as a lot of the frameworks I'm finding seem not to be fully fleshed out or are not still being actively developed.

I think there's a compromise - WordPress recently merged a branch into its core which brought REST API access, which would allow me to connect to WP on the backend while building the frontend using Angular. I'd go full MEAN stack if my client didn't need to update their website rather frequently, but I want it to be easy for them to maintain their content without my assistance (although I'll still need to jump in on occasion to apply updates, but I'll be hosting it for them and can do that quickly with the awesome WP CLI). I haven't made a final decision just yet, but I'm leaning heavily in that direction.

### R1D9 - April 3, 2018
Today I learned, [thanks to a great Base CS post by Vaidehi Joshi](https://medium.com/basecs/a-gentle-introduction-to-graph-theory-77969829ead8), about the basics of graph theory. It's not nearly as complicated as I might've imagined - it covered both directed and undirected graphs and how they differ from trees (although trees are in fact graphs, too). It also briefly examined how relationships on social networks are represented as undirected graphs (Facebook, where a friendship is mutual, a.k.a. bidirectional) and directed graphs (Twitter, where you can follow someone and not be followed in return, a.k.a. directional). I can already envision how to potentially model vertices and edges in JSON format, so I'll be one step ahead when it comes time to apply such concepts in code.

Returning again to Git, I noticed when running the command `git branch -a` that my remote branch I thought to be deleted was still showing in my listing of all branches. Unsurprisingly, [there's a Git command to take care of that](https://stackoverflow.com/questions/5094293/git-remote-branch-deleted-but-still-appears-in-branch-a), and it's a fairly logical one. When you've got a dead branch, much like you'd have on an actual tree or bush, you want to remove it by pruning. Running `git remote prune origin` was all it took to clean up the dead branch and provide an accurate, updated listing of my local and remote branches. I love it (and Stack Overflow, ornery though some of the dwellers there may be)!

In Bash news, I wrote what may be my first functions in my .bash_aliases file. I've written plain old aliases before (where, for example, you might type `projectName` instead of the much more verbose `cd ~/to/your/project/directory`), but I found that a simple alias didn't allow you to work with arguments. I often move files around from the command line and want to immediately change into the directory I just moved the file into, so I created a `mvcd()` function. Instead of typing `mv fileName ~/to/the/target/directory` followed by `cd ~/to/the/target/directory`, I wrap it all into one and just run `mvcd fileName ~/to/the/target/directory`. This moves the file, changes me into the directory I just moved it to, and as a bonus runs `ls` once I'm there to show me a listing of what's in the directory...all in a single command. There's a lot of untapped potential in Bash scripting, and I'm looking forward to getting deeper into it. On a simpler note, I learned that `cd -` will change you back into the last directory you were in. Very handy shortcut.

I finally began drawing out a basic wireframe for my current client's site. I haven't been procrastinating, but all of the background research and tutorials I've been going through have been taking up so much time that I'd temporarily lost sight of the project itself. I decided that, regardless of what architecture I end up using for development, I need to start moving forward with the design itself. I began with pen and paper and attempted to load a picture of my sketch into InVision, but ran into some frustrating issues with my photo orientation (no matter how it showed up in my file explorer, it kept uploading as landscape rather than portrait and I could not change it in the app). I ultimately switched over to another tool with a freemium model, MockFlow, and began wireframing digitally. If I can come up with a more solid workflow, I'll probably go back to starting with pen and paper, but I ultimately will want my sketches digitized in any event.

### R1D10 - April 4, 2018
Today's log will be pretty short, because I didn't actually get around to coding anything. I'm working on one of my more ambitious web projects (which is what a lot of the aforementioned tutorials and learning have been aimed toward), and as anxious as I am to start working on the mechanics of the site, I realized that the proper thing to do would be to invest some more time into researching, planning, and designing the thing before I got in too deep and realized I needed to undo my work.

I say ambitious because my client runs an events company that puts on several distinct events, which effectively function as separate sub-brands under their umbrella. I am currently trying to work out the best way to structure the data and navigation, and I'm working from a mobile-first perspective...which is far more challenging than I'd anticipated. The good news is that once I have the mobile experience planned to my (and, more importantly, my client's) satisfaction, I believe the design for larger viewports will go much more quickly; it's just a matter of unpacking what I've crammed into a small space.

So tonight, my coding time was instead spent Googling furiously and sketching out several different iterations of prospective nav configurations. I've found some ideas that I really like, but the challenge will be converting those into code effectively. I also would really like to use Angular and Node to get the experience on my resume, but the fact is that what I want comes second to what will ultimately work best for the client. I'm looking at several different candidates for frameworks and libraries for the functionality I'm after. I feel like I'm a competent developer, but I'm hardly an expert (yet). If the functionality I'm planning to implement can be pulled off with a pre-existing library, assuming it doesn't have a substantially negative impact on site performance, then I think it would be foolish and a waste of time for me to reinvent the wheel at this point. I want to do the best job I can on this project, but I also don't want to make the client wait six months for me to do everything from scratch with free-range, farm-raised, single origin, hand-crafted code. Sometimes it just makes more sense to use something that other people have gotten working before me. Once my expertise has been developed to the point that I can hammer out CSS and JS without breaking a sweat, then I feel I'll be able to justify building my own stuff entirely from the ground up (but, even then, I suspect I'll still often pull in code from others if I feel it would be best, at least on a per-project basis; I imagine simpler projects could very well benefit from 100% original code).